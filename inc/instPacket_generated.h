// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSTPACKET_NNEXECUTOR_H_
#define FLATBUFFERS_GENERATED_INSTPACKET_NNEXECUTOR_H_

#include "flatbuffers/flatbuffers.h"

namespace NNExecutor {

struct Instruction;

struct Conv;

struct Relu;

struct Pooling;

struct FC;

struct Softmax;

struct InstPacket;

/// Instruction OP code definitions
enum OpCode {
  OpCode_Convolution = 0,
  OpCode_Relu = 1,
  OpCode_Pooling = 2,
  OpCode_FullyConnected = 3,
  OpCode_Softmax = 4,
  OpCode_MIN = OpCode_Convolution,
  OpCode_MAX = OpCode_Softmax
};

inline const OpCode (&EnumValuesOpCode())[5] {
  static const OpCode values[] = {
    OpCode_Convolution,
    OpCode_Relu,
    OpCode_Pooling,
    OpCode_FullyConnected,
    OpCode_Softmax
  };
  return values;
}

inline const char * const *EnumNamesOpCode() {
  static const char * const names[] = {
    "Convolution",
    "Relu",
    "Pooling",
    "FullyConnected",
    "Softmax",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpCode(OpCode e) {
  if (e < OpCode_Convolution || e > OpCode_Softmax) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpCode()[index];
}

enum OpInfo {
  OpInfo_NONE = 0,
  OpInfo_Conv = 1,
  OpInfo_Relu = 2,
  OpInfo_Pooling = 3,
  OpInfo_FC = 4,
  OpInfo_Softmax = 5,
  OpInfo_MIN = OpInfo_NONE,
  OpInfo_MAX = OpInfo_Softmax
};

inline const OpInfo (&EnumValuesOpInfo())[6] {
  static const OpInfo values[] = {
    OpInfo_NONE,
    OpInfo_Conv,
    OpInfo_Relu,
    OpInfo_Pooling,
    OpInfo_FC,
    OpInfo_Softmax
  };
  return values;
}

inline const char * const *EnumNamesOpInfo() {
  static const char * const names[] = {
    "NONE",
    "Conv",
    "Relu",
    "Pooling",
    "FC",
    "Softmax",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpInfo(OpInfo e) {
  if (e < OpInfo_NONE || e > OpInfo_Softmax) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpInfo()[index];
}

template<typename T> struct OpInfoTraits {
  static const OpInfo enum_value = OpInfo_NONE;
};

template<> struct OpInfoTraits<Conv> {
  static const OpInfo enum_value = OpInfo_Conv;
};

template<> struct OpInfoTraits<Relu> {
  static const OpInfo enum_value = OpInfo_Relu;
};

template<> struct OpInfoTraits<Pooling> {
  static const OpInfo enum_value = OpInfo_Pooling;
};

template<> struct OpInfoTraits<FC> {
  static const OpInfo enum_value = OpInfo_FC;
};

template<> struct OpInfoTraits<Softmax> {
  static const OpInfo enum_value = OpInfo_Softmax;
};

bool VerifyOpInfo(flatbuffers::Verifier &verifier, const void *obj, OpInfo type);
bool VerifyOpInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Instruction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE = 4,
    VT_OPERAND_TYPE = 6,
    VT_OPERAND = 8
  };
  OpCode opcode() const {
    return static_cast<OpCode>(GetField<uint8_t>(VT_OPCODE, 0));
  }
  OpInfo operand_type() const {
    return static_cast<OpInfo>(GetField<uint8_t>(VT_OPERAND_TYPE, 0));
  }
  const void *operand() const {
    return GetPointer<const void *>(VT_OPERAND);
  }
  template<typename T> const T *operand_as() const;
  const Conv *operand_as_Conv() const {
    return operand_type() == OpInfo_Conv ? static_cast<const Conv *>(operand()) : nullptr;
  }
  const Relu *operand_as_Relu() const {
    return operand_type() == OpInfo_Relu ? static_cast<const Relu *>(operand()) : nullptr;
  }
  const Pooling *operand_as_Pooling() const {
    return operand_type() == OpInfo_Pooling ? static_cast<const Pooling *>(operand()) : nullptr;
  }
  const FC *operand_as_FC() const {
    return operand_type() == OpInfo_FC ? static_cast<const FC *>(operand()) : nullptr;
  }
  const Softmax *operand_as_Softmax() const {
    return operand_type() == OpInfo_Softmax ? static_cast<const Softmax *>(operand()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPCODE) &&
           VerifyField<uint8_t>(verifier, VT_OPERAND_TYPE) &&
           VerifyOffset(verifier, VT_OPERAND) &&
           VerifyOpInfo(verifier, operand(), operand_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Conv *Instruction::operand_as<Conv>() const {
  return operand_as_Conv();
}

template<> inline const Relu *Instruction::operand_as<Relu>() const {
  return operand_as_Relu();
}

template<> inline const Pooling *Instruction::operand_as<Pooling>() const {
  return operand_as_Pooling();
}

template<> inline const FC *Instruction::operand_as<FC>() const {
  return operand_as_FC();
}

template<> inline const Softmax *Instruction::operand_as<Softmax>() const {
  return operand_as_Softmax();
}

struct InstructionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode(OpCode opcode) {
    fbb_.AddElement<uint8_t>(Instruction::VT_OPCODE, static_cast<uint8_t>(opcode), 0);
  }
  void add_operand_type(OpInfo operand_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_OPERAND_TYPE, static_cast<uint8_t>(operand_type), 0);
  }
  void add_operand(flatbuffers::Offset<void> operand) {
    fbb_.AddOffset(Instruction::VT_OPERAND, operand);
  }
  explicit InstructionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstructionBuilder &operator=(const InstructionBuilder &);
  flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instruction> CreateInstruction(
    flatbuffers::FlatBufferBuilder &_fbb,
    OpCode opcode = OpCode_Convolution,
    OpInfo operand_type = OpInfo_NONE,
    flatbuffers::Offset<void> operand = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_operand(operand);
  builder_.add_operand_type(operand_type);
  builder_.add_opcode(opcode);
  return builder_.Finish();
}

/// Operand info of each instruction (kernel)
struct Conv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_KERNEL_SIZE_W = 6,
    VT_KERNEL_SIZE_H = 8,
    VT_STRIDE_SIZE_W = 10,
    VT_STRIDE_SIZE_H = 12,
    VT_PAD_SIZE_W = 14,
    VT_PAD_SIZE_H = 16,
    VT_WEIGHT = 18,
    VT_BIAS = 20,
    VT_IBUFADDR = 22,
    VT_OBUFADDR = 24
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  int32_t kernel_size_w() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_W, 0);
  }
  int32_t kernel_size_h() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_H, 0);
  }
  int32_t stride_size_w() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_W, 0);
  }
  int32_t stride_size_h() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_H, 0);
  }
  int32_t pad_size_w() const {
    return GetField<int32_t>(VT_PAD_SIZE_W, 0);
  }
  int32_t pad_size_h() const {
    return GetField<int32_t>(VT_PAD_SIZE_H, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  uint64_t ibufaddr() const {
    return GetField<uint64_t>(VT_IBUFADDR, 0);
  }
  uint64_t obufaddr() const {
    return GetField<uint64_t>(VT_OBUFADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_H) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<uint64_t>(verifier, VT_IBUFADDR) &&
           VerifyField<uint64_t>(verifier, VT_OBUFADDR) &&
           verifier.EndTable();
  }
};

struct ConvBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Conv::VT_KERNEL_NAME, kernel_name);
  }
  void add_kernel_size_w(int32_t kernel_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNEL_SIZE_W, kernel_size_w, 0);
  }
  void add_kernel_size_h(int32_t kernel_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNEL_SIZE_H, kernel_size_h, 0);
  }
  void add_stride_size_w(int32_t stride_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_STRIDE_SIZE_W, stride_size_w, 0);
  }
  void add_stride_size_h(int32_t stride_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_STRIDE_SIZE_H, stride_size_h, 0);
  }
  void add_pad_size_w(int32_t pad_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_PAD_SIZE_W, pad_size_w, 0);
  }
  void add_pad_size_h(int32_t pad_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_PAD_SIZE_H, pad_size_h, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Conv::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Conv::VT_BIAS, bias);
  }
  void add_ibufaddr(uint64_t ibufaddr) {
    fbb_.AddElement<uint64_t>(Conv::VT_IBUFADDR, ibufaddr, 0);
  }
  void add_obufaddr(uint64_t obufaddr) {
    fbb_.AddElement<uint64_t>(Conv::VT_OBUFADDR, obufaddr, 0);
  }
  explicit ConvBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConvBuilder &operator=(const ConvBuilder &);
  flatbuffers::Offset<Conv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv> CreateConv(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  ConvBuilder builder_(_fbb);
  builder_.add_obufaddr(obufaddr);
  builder_.add_ibufaddr(ibufaddr);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_pad_size_h(pad_size_h);
  builder_.add_pad_size_w(pad_size_w);
  builder_.add_stride_size_h(stride_size_h);
  builder_.add_stride_size_w(stride_size_w);
  builder_.add_kernel_size_h(kernel_size_h);
  builder_.add_kernel_size_w(kernel_size_w);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv> CreateConvDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return NNExecutor::CreateConv(
      _fbb,
      kernel_name__,
      kernel_size_w,
      kernel_size_h,
      stride_size_w,
      stride_size_h,
      pad_size_w,
      pad_size_h,
      weight__,
      bias__,
      ibufaddr,
      obufaddr);
}

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_IBUFADDR = 6,
    VT_OBUFADDR = 8
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  uint64_t ibufaddr() const {
    return GetField<uint64_t>(VT_IBUFADDR, 0);
  }
  uint64_t obufaddr() const {
    return GetField<uint64_t>(VT_OBUFADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<uint64_t>(verifier, VT_IBUFADDR) &&
           VerifyField<uint64_t>(verifier, VT_OBUFADDR) &&
           verifier.EndTable();
  }
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Relu::VT_KERNEL_NAME, kernel_name);
  }
  void add_ibufaddr(uint64_t ibufaddr) {
    fbb_.AddElement<uint64_t>(Relu::VT_IBUFADDR, ibufaddr, 0);
  }
  void add_obufaddr(uint64_t obufaddr) {
    fbb_.AddElement<uint64_t>(Relu::VT_OBUFADDR, obufaddr, 0);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  ReluBuilder builder_(_fbb);
  builder_.add_obufaddr(obufaddr);
  builder_.add_ibufaddr(ibufaddr);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relu> CreateReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  return NNExecutor::CreateRelu(
      _fbb,
      kernel_name__,
      ibufaddr,
      obufaddr);
}

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE_SIZE = 8,
    VT_PAD_SIZE = 10,
    VT_IBUFADDR = 12,
    VT_OBUFADDR = 14
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  int32_t kernel_size() const {
    return GetField<int32_t>(VT_KERNEL_SIZE, 0);
  }
  int32_t stride_size() const {
    return GetField<int32_t>(VT_STRIDE_SIZE, 0);
  }
  int32_t pad_size() const {
    return GetField<int32_t>(VT_PAD_SIZE, 0);
  }
  uint64_t ibufaddr() const {
    return GetField<uint64_t>(VT_IBUFADDR, 0);
  }
  uint64_t obufaddr() const {
    return GetField<uint64_t>(VT_OBUFADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_IBUFADDR) &&
           VerifyField<uint64_t>(verifier, VT_OBUFADDR) &&
           verifier.EndTable();
  }
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Pooling::VT_KERNEL_NAME, kernel_name);
  }
  void add_kernel_size(int32_t kernel_size) {
    fbb_.AddElement<int32_t>(Pooling::VT_KERNEL_SIZE, kernel_size, 0);
  }
  void add_stride_size(int32_t stride_size) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDE_SIZE, stride_size, 0);
  }
  void add_pad_size(int32_t pad_size) {
    fbb_.AddElement<int32_t>(Pooling::VT_PAD_SIZE, pad_size, 0);
  }
  void add_ibufaddr(uint64_t ibufaddr) {
    fbb_.AddElement<uint64_t>(Pooling::VT_IBUFADDR, ibufaddr, 0);
  }
  void add_obufaddr(uint64_t obufaddr) {
    fbb_.AddElement<uint64_t>(Pooling::VT_OBUFADDR, obufaddr, 0);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    int32_t kernel_size = 0,
    int32_t stride_size = 0,
    int32_t pad_size = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_obufaddr(obufaddr);
  builder_.add_ibufaddr(ibufaddr);
  builder_.add_pad_size(pad_size);
  builder_.add_stride_size(stride_size);
  builder_.add_kernel_size(kernel_size);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pooling> CreatePoolingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    int32_t kernel_size = 0,
    int32_t stride_size = 0,
    int32_t pad_size = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  return NNExecutor::CreatePooling(
      _fbb,
      kernel_name__,
      kernel_size,
      stride_size,
      pad_size,
      ibufaddr,
      obufaddr);
}

struct FC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_IBUFADDR = 10,
    VT_OBUFADDR = 12
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  uint64_t ibufaddr() const {
    return GetField<uint64_t>(VT_IBUFADDR, 0);
  }
  uint64_t obufaddr() const {
    return GetField<uint64_t>(VT_OBUFADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<uint64_t>(verifier, VT_IBUFADDR) &&
           VerifyField<uint64_t>(verifier, VT_OBUFADDR) &&
           verifier.EndTable();
  }
};

struct FCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(FC::VT_KERNEL_NAME, kernel_name);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(FC::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(FC::VT_BIAS, bias);
  }
  void add_ibufaddr(uint64_t ibufaddr) {
    fbb_.AddElement<uint64_t>(FC::VT_IBUFADDR, ibufaddr, 0);
  }
  void add_obufaddr(uint64_t obufaddr) {
    fbb_.AddElement<uint64_t>(FC::VT_OBUFADDR, obufaddr, 0);
  }
  explicit FCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FCBuilder &operator=(const FCBuilder &);
  flatbuffers::Offset<FC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FC>(end);
    return o;
  }
};

inline flatbuffers::Offset<FC> CreateFC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  FCBuilder builder_(_fbb);
  builder_.add_obufaddr(obufaddr);
  builder_.add_ibufaddr(ibufaddr);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FC> CreateFCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return NNExecutor::CreateFC(
      _fbb,
      kernel_name__,
      weight__,
      bias__,
      ibufaddr,
      obufaddr);
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_OP_UNIT_SIZE = 6,
    VT_IBUFADDR = 8,
    VT_OBUFADDR = 10
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  int32_t op_unit_size() const {
    return GetField<int32_t>(VT_OP_UNIT_SIZE, 0);
  }
  uint64_t ibufaddr() const {
    return GetField<uint64_t>(VT_IBUFADDR, 0);
  }
  uint64_t obufaddr() const {
    return GetField<uint64_t>(VT_OBUFADDR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<int32_t>(verifier, VT_OP_UNIT_SIZE) &&
           VerifyField<uint64_t>(verifier, VT_IBUFADDR) &&
           VerifyField<uint64_t>(verifier, VT_OBUFADDR) &&
           verifier.EndTable();
  }
};

struct SoftmaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Softmax::VT_KERNEL_NAME, kernel_name);
  }
  void add_op_unit_size(int32_t op_unit_size) {
    fbb_.AddElement<int32_t>(Softmax::VT_OP_UNIT_SIZE, op_unit_size, 0);
  }
  void add_ibufaddr(uint64_t ibufaddr) {
    fbb_.AddElement<uint64_t>(Softmax::VT_IBUFADDR, ibufaddr, 0);
  }
  void add_obufaddr(uint64_t obufaddr) {
    fbb_.AddElement<uint64_t>(Softmax::VT_OBUFADDR, obufaddr, 0);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxBuilder &operator=(const SoftmaxBuilder &);
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    int32_t op_unit_size = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_obufaddr(obufaddr);
  builder_.add_ibufaddr(ibufaddr);
  builder_.add_op_unit_size(op_unit_size);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    int32_t op_unit_size = 0,
    uint64_t ibufaddr = 0,
    uint64_t obufaddr = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  return NNExecutor::CreateSoftmax(
      _fbb,
      kernel_name__,
      op_unit_size,
      ibufaddr,
      obufaddr);
}

/// root table definition
struct InstPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Instruction>> *packet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Instruction>> *>(VT_PACKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PACKET) &&
           verifier.VerifyVector(packet()) &&
           verifier.VerifyVectorOfTables(packet()) &&
           verifier.EndTable();
  }
};

struct InstPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instruction>>> packet) {
    fbb_.AddOffset(InstPacket::VT_PACKET, packet);
  }
  explicit InstPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstPacketBuilder &operator=(const InstPacketBuilder &);
  flatbuffers::Offset<InstPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstPacket> CreateInstPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instruction>>> packet = 0) {
  InstPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstPacket> CreateInstPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Instruction>> *packet = nullptr) {
  auto packet__ = packet ? _fbb.CreateVector<flatbuffers::Offset<Instruction>>(*packet) : 0;
  return NNExecutor::CreateInstPacket(
      _fbb,
      packet__);
}

inline bool VerifyOpInfo(flatbuffers::Verifier &verifier, const void *obj, OpInfo type) {
  switch (type) {
    case OpInfo_NONE: {
      return true;
    }
    case OpInfo_Conv: {
      auto ptr = reinterpret_cast<const Conv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Relu: {
      auto ptr = reinterpret_cast<const Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_FC: {
      auto ptr = reinterpret_cast<const FC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Softmax: {
      auto ptr = reinterpret_cast<const Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOpInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpInfo(
        verifier,  values->Get(i), types->GetEnum<OpInfo>(i))) {
      return false;
    }
  }
  return true;
}

inline const NNExecutor::InstPacket *GetInstPacket(const void *buf) {
  return flatbuffers::GetRoot<NNExecutor::InstPacket>(buf);
}

inline const NNExecutor::InstPacket *GetSizePrefixedInstPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<NNExecutor::InstPacket>(buf);
}

inline bool VerifyInstPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NNExecutor::InstPacket>(nullptr);
}

inline bool VerifySizePrefixedInstPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NNExecutor::InstPacket>(nullptr);
}

inline void FinishInstPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NNExecutor::InstPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedInstPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NNExecutor::InstPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NNExecutor

#endif  // FLATBUFFERS_GENERATED_INSTPACKET_NNEXECUTOR_H_
