// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INSTPACKET_NNFRAMEWORK_H_
#define FLATBUFFERS_GENERATED_INSTPACKET_NNFRAMEWORK_H_

#include "flatbuffers/flatbuffers.h"

namespace NNFramework {

struct Instruction;

struct TileInfo;

struct MemAlloc;

struct MemFree;

struct Input;

struct Output;

struct Conv;

struct Relu;

struct Pooling;

struct FC;

struct Softmax;

struct InstPacket;

/// Instruction OP code definitions
enum OpCode {
  OpCode_MemAlloc = 0,
  OpCode_Input = 1,
  OpCode_Convolution = 2,
  OpCode_Relu = 3,
  OpCode_Pooling = 4,
  OpCode_FullyConnected = 5,
  OpCode_Softmax = 6,
  OpCode_Output = 7,
  OpCode_MemFree = 8,
  OpCode_MIN = OpCode_MemAlloc,
  OpCode_MAX = OpCode_MemFree
};

inline const OpCode (&EnumValuesOpCode())[9] {
  static const OpCode values[] = {
    OpCode_MemAlloc,
    OpCode_Input,
    OpCode_Convolution,
    OpCode_Relu,
    OpCode_Pooling,
    OpCode_FullyConnected,
    OpCode_Softmax,
    OpCode_Output,
    OpCode_MemFree
  };
  return values;
}

inline const char * const *EnumNamesOpCode() {
  static const char * const names[] = {
    "MemAlloc",
    "Input",
    "Convolution",
    "Relu",
    "Pooling",
    "FullyConnected",
    "Softmax",
    "Output",
    "MemFree",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpCode(OpCode e) {
  if (e < OpCode_MemAlloc || e > OpCode_MemFree) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpCode()[index];
}

enum OpInfo {
  OpInfo_NONE = 0,
  OpInfo_MemAlloc = 1,
  OpInfo_Input = 2,
  OpInfo_Conv = 3,
  OpInfo_Relu = 4,
  OpInfo_Pooling = 5,
  OpInfo_FC = 6,
  OpInfo_Softmax = 7,
  OpInfo_Output = 8,
  OpInfo_MemFree = 9,
  OpInfo_MIN = OpInfo_NONE,
  OpInfo_MAX = OpInfo_MemFree
};

inline const OpInfo (&EnumValuesOpInfo())[10] {
  static const OpInfo values[] = {
    OpInfo_NONE,
    OpInfo_MemAlloc,
    OpInfo_Input,
    OpInfo_Conv,
    OpInfo_Relu,
    OpInfo_Pooling,
    OpInfo_FC,
    OpInfo_Softmax,
    OpInfo_Output,
    OpInfo_MemFree
  };
  return values;
}

inline const char * const *EnumNamesOpInfo() {
  static const char * const names[] = {
    "NONE",
    "MemAlloc",
    "Input",
    "Conv",
    "Relu",
    "Pooling",
    "FC",
    "Softmax",
    "Output",
    "MemFree",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpInfo(OpInfo e) {
  if (e < OpInfo_NONE || e > OpInfo_MemFree) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpInfo()[index];
}

template<typename T> struct OpInfoTraits {
  static const OpInfo enum_value = OpInfo_NONE;
};

template<> struct OpInfoTraits<MemAlloc> {
  static const OpInfo enum_value = OpInfo_MemAlloc;
};

template<> struct OpInfoTraits<Input> {
  static const OpInfo enum_value = OpInfo_Input;
};

template<> struct OpInfoTraits<Conv> {
  static const OpInfo enum_value = OpInfo_Conv;
};

template<> struct OpInfoTraits<Relu> {
  static const OpInfo enum_value = OpInfo_Relu;
};

template<> struct OpInfoTraits<Pooling> {
  static const OpInfo enum_value = OpInfo_Pooling;
};

template<> struct OpInfoTraits<FC> {
  static const OpInfo enum_value = OpInfo_FC;
};

template<> struct OpInfoTraits<Softmax> {
  static const OpInfo enum_value = OpInfo_Softmax;
};

template<> struct OpInfoTraits<Output> {
  static const OpInfo enum_value = OpInfo_Output;
};

template<> struct OpInfoTraits<MemFree> {
  static const OpInfo enum_value = OpInfo_MemFree;
};

bool VerifyOpInfo(flatbuffers::Verifier &verifier, const void *obj, OpInfo type);
bool VerifyOpInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Instruction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE = 4,
    VT_OPERAND_TYPE = 6,
    VT_OPERAND = 8
  };
  OpCode opcode() const {
    return static_cast<OpCode>(GetField<uint8_t>(VT_OPCODE, 0));
  }
  OpInfo operand_type() const {
    return static_cast<OpInfo>(GetField<uint8_t>(VT_OPERAND_TYPE, 0));
  }
  const void *operand() const {
    return GetPointer<const void *>(VT_OPERAND);
  }
  template<typename T> const T *operand_as() const;
  const MemAlloc *operand_as_MemAlloc() const {
    return operand_type() == OpInfo_MemAlloc ? static_cast<const MemAlloc *>(operand()) : nullptr;
  }
  const Input *operand_as_Input() const {
    return operand_type() == OpInfo_Input ? static_cast<const Input *>(operand()) : nullptr;
  }
  const Conv *operand_as_Conv() const {
    return operand_type() == OpInfo_Conv ? static_cast<const Conv *>(operand()) : nullptr;
  }
  const Relu *operand_as_Relu() const {
    return operand_type() == OpInfo_Relu ? static_cast<const Relu *>(operand()) : nullptr;
  }
  const Pooling *operand_as_Pooling() const {
    return operand_type() == OpInfo_Pooling ? static_cast<const Pooling *>(operand()) : nullptr;
  }
  const FC *operand_as_FC() const {
    return operand_type() == OpInfo_FC ? static_cast<const FC *>(operand()) : nullptr;
  }
  const Softmax *operand_as_Softmax() const {
    return operand_type() == OpInfo_Softmax ? static_cast<const Softmax *>(operand()) : nullptr;
  }
  const Output *operand_as_Output() const {
    return operand_type() == OpInfo_Output ? static_cast<const Output *>(operand()) : nullptr;
  }
  const MemFree *operand_as_MemFree() const {
    return operand_type() == OpInfo_MemFree ? static_cast<const MemFree *>(operand()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPCODE) &&
           VerifyField<uint8_t>(verifier, VT_OPERAND_TYPE) &&
           VerifyOffset(verifier, VT_OPERAND) &&
           VerifyOpInfo(verifier, operand(), operand_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MemAlloc *Instruction::operand_as<MemAlloc>() const {
  return operand_as_MemAlloc();
}

template<> inline const Input *Instruction::operand_as<Input>() const {
  return operand_as_Input();
}

template<> inline const Conv *Instruction::operand_as<Conv>() const {
  return operand_as_Conv();
}

template<> inline const Relu *Instruction::operand_as<Relu>() const {
  return operand_as_Relu();
}

template<> inline const Pooling *Instruction::operand_as<Pooling>() const {
  return operand_as_Pooling();
}

template<> inline const FC *Instruction::operand_as<FC>() const {
  return operand_as_FC();
}

template<> inline const Softmax *Instruction::operand_as<Softmax>() const {
  return operand_as_Softmax();
}

template<> inline const Output *Instruction::operand_as<Output>() const {
  return operand_as_Output();
}

template<> inline const MemFree *Instruction::operand_as<MemFree>() const {
  return operand_as_MemFree();
}

struct InstructionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode(OpCode opcode) {
    fbb_.AddElement<uint8_t>(Instruction::VT_OPCODE, static_cast<uint8_t>(opcode), 0);
  }
  void add_operand_type(OpInfo operand_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_OPERAND_TYPE, static_cast<uint8_t>(operand_type), 0);
  }
  void add_operand(flatbuffers::Offset<void> operand) {
    fbb_.AddOffset(Instruction::VT_OPERAND, operand);
  }
  explicit InstructionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstructionBuilder &operator=(const InstructionBuilder &);
  flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline flatbuffers::Offset<Instruction> CreateInstruction(
    flatbuffers::FlatBufferBuilder &_fbb,
    OpCode opcode = OpCode_MemAlloc,
    OpInfo operand_type = OpInfo_NONE,
    flatbuffers::Offset<void> operand = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_operand(operand);
  builder_.add_operand_type(operand_type);
  builder_.add_opcode(opcode);
  return builder_.Finish();
}

struct TileInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDR = 4,
    VT_TSIZE = 6
  };
  uint64_t addr() const {
    return GetField<uint64_t>(VT_ADDR, 0);
  }
  const flatbuffers::Vector<int32_t> *tsize() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TSIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDR) &&
           VerifyOffset(verifier, VT_TSIZE) &&
           verifier.VerifyVector(tsize()) &&
           verifier.EndTable();
  }
};

struct TileInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_addr(uint64_t addr) {
    fbb_.AddElement<uint64_t>(TileInfo::VT_ADDR, addr, 0);
  }
  void add_tsize(flatbuffers::Offset<flatbuffers::Vector<int32_t>> tsize) {
    fbb_.AddOffset(TileInfo::VT_TSIZE, tsize);
  }
  explicit TileInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileInfoBuilder &operator=(const TileInfoBuilder &);
  flatbuffers::Offset<TileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileInfo> CreateTileInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t addr = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> tsize = 0) {
  TileInfoBuilder builder_(_fbb);
  builder_.add_addr(addr);
  builder_.add_tsize(tsize);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileInfo> CreateTileInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t addr = 0,
    const std::vector<int32_t> *tsize = nullptr) {
  auto tsize__ = tsize ? _fbb.CreateVector<int32_t>(*tsize) : 0;
  return NNFramework::CreateTileInfo(
      _fbb,
      addr,
      tsize__);
}

/// Operand info of each instruction (kernel)
struct MemAlloc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_TOTAL_BUFF_SIZE = 6
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  uint64_t total_buff_size() const {
    return GetField<uint64_t>(VT_TOTAL_BUFF_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_BUFF_SIZE) &&
           verifier.EndTable();
  }
};

struct MemAllocBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(MemAlloc::VT_KERNEL_NAME, kernel_name);
  }
  void add_total_buff_size(uint64_t total_buff_size) {
    fbb_.AddElement<uint64_t>(MemAlloc::VT_TOTAL_BUFF_SIZE, total_buff_size, 0);
  }
  explicit MemAllocBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemAllocBuilder &operator=(const MemAllocBuilder &);
  flatbuffers::Offset<MemAlloc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemAlloc>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemAlloc> CreateMemAlloc(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    uint64_t total_buff_size = 0) {
  MemAllocBuilder builder_(_fbb);
  builder_.add_total_buff_size(total_buff_size);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MemAlloc> CreateMemAllocDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    uint64_t total_buff_size = 0) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  return NNFramework::CreateMemAlloc(
      _fbb,
      kernel_name__,
      total_buff_size);
}

struct MemFree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           verifier.EndTable();
  }
};

struct MemFreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(MemFree::VT_KERNEL_NAME, kernel_name);
  }
  explicit MemFreeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MemFreeBuilder &operator=(const MemFreeBuilder &);
  flatbuffers::Offset<MemFree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MemFree>(end);
    return o;
  }
};

inline flatbuffers::Offset<MemFree> CreateMemFree(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0) {
  MemFreeBuilder builder_(_fbb);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MemFree> CreateMemFreeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  return NNFramework::CreateMemFree(
      _fbb,
      kernel_name__);
}

struct Input FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_OTILE = 6
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Input::VT_KERNEL_NAME, kernel_name);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(Input::VT_OTILE, otile);
  }
  explicit InputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InputBuilder &operator=(const InputBuilder &);
  flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline flatbuffers::Offset<Input> CreateInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  InputBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Input> CreateInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreateInput(
      _fbb,
      kernel_name__,
      otile__);
}

struct Output FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_ITILE = 6
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           verifier.EndTable();
  }
};

struct OutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Output::VT_KERNEL_NAME, kernel_name);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(Output::VT_ITILE, itile);
  }
  explicit OutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OutputBuilder &operator=(const OutputBuilder &);
  flatbuffers::Offset<Output> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Output>(end);
    return o;
  }
};

inline flatbuffers::Offset<Output> CreateOutput(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0) {
  OutputBuilder builder_(_fbb);
  builder_.add_itile(itile);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Output> CreateOutputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  return NNFramework::CreateOutput(
      _fbb,
      kernel_name__,
      itile__);
}

struct Conv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_KERNEL_SIZE_W = 6,
    VT_KERNEL_SIZE_H = 8,
    VT_STRIDE_SIZE_W = 10,
    VT_STRIDE_SIZE_H = 12,
    VT_PAD_SIZE_W = 14,
    VT_PAD_SIZE_H = 16,
    VT_WEIGHT = 18,
    VT_BIAS = 20,
    VT_ITILE = 22,
    VT_OTILE = 24
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  int32_t kernel_size_w() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_W, 0);
  }
  int32_t kernel_size_h() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_H, 0);
  }
  int32_t stride_size_w() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_W, 0);
  }
  int32_t stride_size_h() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_H, 0);
  }
  int32_t pad_size_w() const {
    return GetField<int32_t>(VT_PAD_SIZE_W, 0);
  }
  int32_t pad_size_h() const {
    return GetField<int32_t>(VT_PAD_SIZE_H, 0);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_H) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct ConvBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Conv::VT_KERNEL_NAME, kernel_name);
  }
  void add_kernel_size_w(int32_t kernel_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNEL_SIZE_W, kernel_size_w, 0);
  }
  void add_kernel_size_h(int32_t kernel_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_KERNEL_SIZE_H, kernel_size_h, 0);
  }
  void add_stride_size_w(int32_t stride_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_STRIDE_SIZE_W, stride_size_w, 0);
  }
  void add_stride_size_h(int32_t stride_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_STRIDE_SIZE_H, stride_size_h, 0);
  }
  void add_pad_size_w(int32_t pad_size_w) {
    fbb_.AddElement<int32_t>(Conv::VT_PAD_SIZE_W, pad_size_w, 0);
  }
  void add_pad_size_h(int32_t pad_size_h) {
    fbb_.AddElement<int32_t>(Conv::VT_PAD_SIZE_H, pad_size_h, 0);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Conv::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Conv::VT_BIAS, bias);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(Conv::VT_ITILE, itile);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(Conv::VT_OTILE, otile);
  }
  explicit ConvBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConvBuilder &operator=(const ConvBuilder &);
  flatbuffers::Offset<Conv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv> CreateConv(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  ConvBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_itile(itile);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_pad_size_h(pad_size_h);
  builder_.add_pad_size_w(pad_size_w);
  builder_.add_stride_size_h(stride_size_h);
  builder_.add_stride_size_w(stride_size_w);
  builder_.add_kernel_size_h(kernel_size_h);
  builder_.add_kernel_size_w(kernel_size_w);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv> CreateConvDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreateConv(
      _fbb,
      kernel_name__,
      kernel_size_w,
      kernel_size_h,
      stride_size_w,
      stride_size_h,
      pad_size_w,
      pad_size_h,
      weight__,
      bias__,
      itile__,
      otile__);
}

struct Relu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_ITILE = 6,
    VT_OTILE = 8
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct ReluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Relu::VT_KERNEL_NAME, kernel_name);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(Relu::VT_ITILE, itile);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(Relu::VT_OTILE, otile);
  }
  explicit ReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReluBuilder &operator=(const ReluBuilder &);
  flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Relu> CreateRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  ReluBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_itile(itile);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Relu> CreateReluDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreateRelu(
      _fbb,
      kernel_name__,
      itile__,
      otile__);
}

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_KERNEL_SIZE_W = 6,
    VT_KERNEL_SIZE_H = 8,
    VT_STRIDE_SIZE_W = 10,
    VT_STRIDE_SIZE_H = 12,
    VT_PAD_SIZE_W = 14,
    VT_PAD_SIZE_H = 16,
    VT_ITILE = 18,
    VT_OTILE = 20
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  int32_t kernel_size_w() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_W, 0);
  }
  int32_t kernel_size_h() const {
    return GetField<int32_t>(VT_KERNEL_SIZE_H, 0);
  }
  int32_t stride_size_w() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_W, 0);
  }
  int32_t stride_size_h() const {
    return GetField<int32_t>(VT_STRIDE_SIZE_H, 0);
  }
  int32_t pad_size_w() const {
    return GetField<int32_t>(VT_PAD_SIZE_W, 0);
  }
  int32_t pad_size_h() const {
    return GetField<int32_t>(VT_PAD_SIZE_H, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_KERNEL_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_SIZE_H) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_PAD_SIZE_H) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Pooling::VT_KERNEL_NAME, kernel_name);
  }
  void add_kernel_size_w(int32_t kernel_size_w) {
    fbb_.AddElement<int32_t>(Pooling::VT_KERNEL_SIZE_W, kernel_size_w, 0);
  }
  void add_kernel_size_h(int32_t kernel_size_h) {
    fbb_.AddElement<int32_t>(Pooling::VT_KERNEL_SIZE_H, kernel_size_h, 0);
  }
  void add_stride_size_w(int32_t stride_size_w) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDE_SIZE_W, stride_size_w, 0);
  }
  void add_stride_size_h(int32_t stride_size_h) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDE_SIZE_H, stride_size_h, 0);
  }
  void add_pad_size_w(int32_t pad_size_w) {
    fbb_.AddElement<int32_t>(Pooling::VT_PAD_SIZE_W, pad_size_w, 0);
  }
  void add_pad_size_h(int32_t pad_size_h) {
    fbb_.AddElement<int32_t>(Pooling::VT_PAD_SIZE_H, pad_size_h, 0);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(Pooling::VT_ITILE, itile);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(Pooling::VT_OTILE, otile);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_itile(itile);
  builder_.add_pad_size_h(pad_size_h);
  builder_.add_pad_size_w(pad_size_w);
  builder_.add_stride_size_h(stride_size_h);
  builder_.add_stride_size_w(stride_size_w);
  builder_.add_kernel_size_h(kernel_size_h);
  builder_.add_kernel_size_w(kernel_size_w);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pooling> CreatePoolingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    int32_t kernel_size_w = 0,
    int32_t kernel_size_h = 0,
    int32_t stride_size_w = 0,
    int32_t stride_size_h = 0,
    int32_t pad_size_w = 0,
    int32_t pad_size_h = 0,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreatePooling(
      _fbb,
      kernel_name__,
      kernel_size_w,
      kernel_size_h,
      stride_size_w,
      stride_size_h,
      pad_size_w,
      pad_size_h,
      itile__,
      otile__);
}

struct FC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_ITILE = 10,
    VT_OTILE = 12
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<float> *weight() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const flatbuffers::Vector<float> *bias() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct FCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(FC::VT_KERNEL_NAME, kernel_name);
  }
  void add_weight(flatbuffers::Offset<flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(FC::VT_WEIGHT, weight);
  }
  void add_bias(flatbuffers::Offset<flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(FC::VT_BIAS, bias);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(FC::VT_ITILE, itile);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(FC::VT_OTILE, otile);
  }
  explicit FCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FCBuilder &operator=(const FCBuilder &);
  flatbuffers::Offset<FC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FC>(end);
    return o;
  }
};

inline flatbuffers::Offset<FC> CreateFC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> weight = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> bias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  FCBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_itile(itile);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FC> CreateFCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreateFC(
      _fbb,
      kernel_name__,
      weight__,
      bias__,
      itile__,
      otile__);
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_NAME = 4,
    VT_ITILE = 6,
    VT_OTILE = 8
  };
  const flatbuffers::String *kernel_name() const {
    return GetPointer<const flatbuffers::String *>(VT_KERNEL_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *itile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_ITILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *otile() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TileInfo>> *>(VT_OTILE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_NAME) &&
           verifier.VerifyString(kernel_name()) &&
           VerifyOffset(verifier, VT_ITILE) &&
           verifier.VerifyVector(itile()) &&
           verifier.VerifyVectorOfTables(itile()) &&
           VerifyOffset(verifier, VT_OTILE) &&
           verifier.VerifyVector(otile()) &&
           verifier.VerifyVectorOfTables(otile()) &&
           verifier.EndTable();
  }
};

struct SoftmaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_name(flatbuffers::Offset<flatbuffers::String> kernel_name) {
    fbb_.AddOffset(Softmax::VT_KERNEL_NAME, kernel_name);
  }
  void add_itile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile) {
    fbb_.AddOffset(Softmax::VT_ITILE, itile);
  }
  void add_otile(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile) {
    fbb_.AddOffset(Softmax::VT_OTILE, otile);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxBuilder &operator=(const SoftmaxBuilder &);
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> kernel_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> itile = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TileInfo>>> otile = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_otile(otile);
  builder_.add_itile(itile);
  builder_.add_kernel_name(kernel_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *kernel_name = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *itile = nullptr,
    const std::vector<flatbuffers::Offset<TileInfo>> *otile = nullptr) {
  auto kernel_name__ = kernel_name ? _fbb.CreateString(kernel_name) : 0;
  auto itile__ = itile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*itile) : 0;
  auto otile__ = otile ? _fbb.CreateVector<flatbuffers::Offset<TileInfo>>(*otile) : 0;
  return NNFramework::CreateSoftmax(
      _fbb,
      kernel_name__,
      itile__,
      otile__);
}

/// root table definition
struct InstPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Instruction>> *packet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Instruction>> *>(VT_PACKET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PACKET) &&
           verifier.VerifyVector(packet()) &&
           verifier.VerifyVectorOfTables(packet()) &&
           verifier.EndTable();
  }
};

struct InstPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instruction>>> packet) {
    fbb_.AddOffset(InstPacket::VT_PACKET, packet);
  }
  explicit InstPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstPacketBuilder &operator=(const InstPacketBuilder &);
  flatbuffers::Offset<InstPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstPacket> CreateInstPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Instruction>>> packet = 0) {
  InstPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  return builder_.Finish();
}

inline flatbuffers::Offset<InstPacket> CreateInstPacketDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Instruction>> *packet = nullptr) {
  auto packet__ = packet ? _fbb.CreateVector<flatbuffers::Offset<Instruction>>(*packet) : 0;
  return NNFramework::CreateInstPacket(
      _fbb,
      packet__);
}

inline bool VerifyOpInfo(flatbuffers::Verifier &verifier, const void *obj, OpInfo type) {
  switch (type) {
    case OpInfo_NONE: {
      return true;
    }
    case OpInfo_MemAlloc: {
      auto ptr = reinterpret_cast<const MemAlloc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Input: {
      auto ptr = reinterpret_cast<const Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Conv: {
      auto ptr = reinterpret_cast<const Conv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Relu: {
      auto ptr = reinterpret_cast<const Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_FC: {
      auto ptr = reinterpret_cast<const FC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Softmax: {
      auto ptr = reinterpret_cast<const Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_Output: {
      auto ptr = reinterpret_cast<const Output *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpInfo_MemFree: {
      auto ptr = reinterpret_cast<const MemFree *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOpInfoVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpInfo(
        verifier,  values->Get(i), types->GetEnum<OpInfo>(i))) {
      return false;
    }
  }
  return true;
}

inline const NNFramework::InstPacket *GetInstPacket(const void *buf) {
  return flatbuffers::GetRoot<NNFramework::InstPacket>(buf);
}

inline const NNFramework::InstPacket *GetSizePrefixedInstPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<NNFramework::InstPacket>(buf);
}

inline bool VerifyInstPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<NNFramework::InstPacket>(nullptr);
}

inline bool VerifySizePrefixedInstPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<NNFramework::InstPacket>(nullptr);
}

inline void FinishInstPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NNFramework::InstPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedInstPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<NNFramework::InstPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace NNFramework

#endif  // FLATBUFFERS_GENERATED_INSTPACKET_NNFRAMEWORK_H_
